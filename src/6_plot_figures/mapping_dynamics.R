################################################################################
# Author: Gabriele Midolo
# Email: midolo@fzp.czu.cz
# Date: 18.07.2025
################################################################################

# Description: Visualize maps of species richness dynamics on a shiny app

################################################################################

#### 1. Load and prepare data ####

# Load packages
library(shiny)
library(sf)
library(dplyr)
library(leaflet)
library(viridis)
library(tidyr)
library(readr)

# Load prediction data
dat <- './data/preds/preds_stdpltsz.rf.csv' %>%
  read_csv(show_col_types = FALSE) %>%
  dplyr::select(x, y, habitat, year, contains('S_pred_')) %>%
  filter(year >= 1960 & year <= 2020)

# Manually centering plots by rounding coordinates
fact = 1000*10 # 10 km distance
dat <- dat %>%
  mutate(x = round(x / fact) * fact,
         y = round(y / fact) * fact) %>%
  group_by(x, y, habitat) %>%
  summarise(
    n = n(), # number of plots
    across(where(is.numeric), mean, .names = "{.col}"), # average predictions across nearest plots per year
    .groups = 'drop'
  )

#### 2. Define UI ####

ui <- fluidPage(
  titlePanel(
    tags$h3("Six decades of change in alpha diversity of European plant communities",
            style = "font-size: 24px; font-weight: bold; color: #333;")
  ),
  sidebarLayout(
    sidebarPanel(
      
      # General Description Section
      div(style = "margin-bottom: 20px; font-size: 1.1em; line-height: 1.4;",
          p(HTML("We interpolated spatiotemporal changes in vascular plant species richness between 1960 and 2020 using Random Forests. The results displayed on this dashboard were generated by applying our model to data from 660,748 European vegetation plots sampled during that period retrieved from the <a href='https://euroveg.org/eva-database/' target='_blank'>European Vegetation Archive</a> (<a href='https://doi.org/10.1111/avsc.12519' target='_blank'>Chytrý et al. 2020</a>).")),
          p(HTML("Species richness estimates from individual plots were aggregated onto a 10 km &times; 10 km grid. In the map, point size represents the number of plots within each grid cell.")), # Changed x to &times; for proper multiplication sign
          p(HTML("Our interpolation approach was validated against 22,852 independent time series from <a href='https://euroveg.org/resurvey/' target='_blank'>ReSurveyEurope</a> (<a href='https://doi.org/10.1111/jvs.13235' target='_blank'>Knollová et al. 2024</a>).")),
          p(HTML('This application uses data and code deposited at <a href="https://github.com/gmidolo/interpolated_S_change" target="_blank">github.com/gmidolo/interpolated_S_change</a>'))
      ),
      
      selectInput("mode", "Mapping mode:",
                  choices = c("Species richness change", "Species richness per year")),
      selectInput("habitat", "Habitat:",
                  choices = c("Forest", "Grassland", "Scrub", "Wetland")),
      
      div(style = "font-size: 1.0em; font-style: italic; margin-top: 2px; margin-bottom: 15px;",
          textOutput("plot_size_note")), # dynamic note below habitat selector
      
      conditionalPanel(
        condition = "input.mode == 'Species richness change'",
        sliderInput("years", "Comparison Period:",
                    min = 1960, max = 2020, value = c(1960, 2020), sep = ""),
        radioButtons("metric", "Metric of change:",
                     choices = c("Percentage (%)" = "perc",
                                 "Log Response Ratio" = "lnrr",
                                 "No. Species" = "diff"))
      ),
      conditionalPanel(
        condition = "input.mode == 'Species richness per year'",
        sliderInput("single_year", "Select Year:",
                    min = 1960, max = 2020, value = 1960, sep = "")
      ),
      # Author information with ORCID and affiliation
      div(style = "margin-top: 40px; text-align: left; font-size: 0.9em; color: #555;",
          p(HTML('Author: <strong>Gabriele Midolo</strong><a href="https://orcid.org/0000-0003-1316-2546" target="_blank" style="margin-left: 5px;"><img src="https://upload.wikimedia.org/wikipedia/commons/0/06/ORCID_iD.svg" width="15" style="vertical-align: middle;"/></a> (<a href="mailto:midolo@fzp.czu.cz">midolo@fzp.czu.cz</a>)')),
          p("Department of Spatial Sciences, Faculty of Environmental Sciences, Czech University of Life Sciences Prague, Kamýcká 129, 165 00, Praha - Suchdol, Czech Republic"),
          p(paste0("Date: ", format(Sys.Date(), "%d.%m.%Y"))),
      )
    ), # End of sidebarPanel
    mainPanel(
      leafletOutput("map", height = "800px")
    )
  )
)


# 3. Define server ####

server <- function(input, output, session) {
  
  output$plot_size_note <- renderText({
    req(input$habitat)
    
    sizes <- c(
      "Forest" = "300 m²",
      "Grassland" = "20 m²",
      "Scrub" = "64 m²",
      "Wetland" = "50 m²"
    )
    
    habitat_name <- c(
      "Forest" = "forests",
      "Grassland" = "grasslands",
      "Scrub" = "scrub",
      "Wetland" = "wetlands"
    )
    
    paste0("Predictions at ", sizes[input$habitat], " for ", habitat_name[input$habitat], ".")
    
  })
  
  dat_sf <- reactive({
    st_as_sf(dat, coords = c("x", "y"), crs = 25832) %>%
      filter(habitat == input$habitat) %>%
      st_transform(4326)
  })
  
  change_data <- reactive({
    req(input$years[1] < input$years[2])
    dat_hab <- dat_sf()
    y1 <- paste0("S_pred_", input$years[1])
    y2 <- paste0("S_pred_", input$years[2])
    
    dat_hab <- dat_hab %>%
      mutate(change_value = case_when(
        input$metric == "perc"  ~ 100 * ((.data[[y2]] - .data[[y1]]) / .data[[y1]]),
        input$metric == "lnrr"  ~ log(.data[[y2]] / .data[[y1]]),
        input$metric == "diff"  ~ .data[[y2]] - .data[[y1]]
      ))
    
    dat_hab <- dat_hab %>%
      mutate(change_cat = case_when(
        input$metric == "perc" ~ cut(change_value,
                                     breaks = c(-Inf, -50, -25, -10, -5, 5, 10, 25, 50, Inf),
                                     labels = c('< -50%', '-50% – -25%', '-25% – -10%', '-10% – -5%',
                                                '-5% – 5%', '5% – 10%', '10% – 25%', '25% – 50%', '> 50%'),
                                     include.lowest = TRUE
        ),
        input$metric == "lnrr" ~ cut(change_value,
                                     breaks = c(-10, -0.5, -0.1, -0.05, 0.05, 0.1, 0.5, 10),
                                     labels = c('< -0.5', '-0.5 – -0.1', '-0.1 – -0.05', '-0.05 – 0.05',
                                                '0.05 – 0.1', '0.1 – 0.5', '> 0.5'),
                                     include.lowest = TRUE
        ),
        input$metric == "diff" ~ cut(change_value,
                                     breaks = c(-Inf, -10, -5, -1, 1, 5, 10, Inf),
                                     labels = c('< -10', '-10 – -5', '-5 – -1', '-1 – 1',
                                                '1 – 5', '5 – 10', '> 10'),
                                     include.lowest = TRUE
        )
      ))
    
    dat_hab
  })
  
  snapshot_data <- reactive({
    dat_hab <- dat_sf()
    yr <- paste0("S_pred_", input$single_year)
    dat_hab %>%
      mutate(S_value = log10(.data[[yr]])) # Keep log10 richness for coloring
  })
  
  # Initialize the map once
  output$map <- renderLeaflet({
    leaflet() %>%
      addProviderTiles("Esri.WorldGrayCanvas") %>%
      setView(lng = 15, lat = 57, zoom = 4)
  })
  
  # Observe inputs for map updates
  observe({
    leafletProxy("map") %>% clearControls() # Always clear controls to redraw legend
    
    current_zoom <- input$map_zoom
    if (is.null(current_zoom)) current_zoom <- 4 # default zoom
    
    # Adjust point size by zooming level
    fac = 0.2
    zoomy = input$map_zoom
    # scale_factor = ifelse(zoomy*fac<=1, 1, zoomy*fac)
    scale_factor = zoomy*fac
    
    if (input$mode == "Species richness change") {
      dat_plot <- change_data()
      
      if (input$metric == "perc") {
        levels_lab <- c('< -50%', '-50% – -25%', '-25% – -10%', '-10% – -5%',
                        '-5% – 5%', '5% – 10%', '10% – 25%', '25% – 50%', '> 50%')
      } else if (input$metric == "lnrr") {
        levels_lab <- c('< -0.5', '-0.5 – -0.1', '-0.1 – -0.05', '-0.05 – 0.05',
                        '0.05 – 0.1', '0.1 – 0.5', '> 0.5')
      } else {
        levels_lab <- c('< -10', '-10 – -5', '-5 – -1', '-1 – 1',
                        '1 – 5', '5 – 10', '> 10')
      }
      
      cols <- hcl.colors(length(levels_lab), "Spectral")
      pal <- colorFactor(palette = cols, levels = levels_lab)
      
      leafletProxy("map") %>%
        # Use a consistent layerId to allow Leaflet to update existing markers
        addCircleMarkers(data = dat_plot,
                         layerId = ~paste0("point_", geometry_id), # Assuming a unique ID for each point
                         radius = ~(log(n)+2) * scale_factor,
                         color = ~pal(change_cat),
                         stroke = FALSE,
                         fillOpacity = 0.7,
                         popup = ~paste0("Mean species richness change: ", round(change_value, 2),
                                         "<br>No. plots: ", n)) %>%
        addLegend("topright", pal = pal, values = dat_plot$change_cat,
                  title = "Species richness change", opacity = 0.9)
      
    } else { # input$mode == "Species richness per year"
      dat_plot <- snapshot_data()
      
      dat_plot <- dat_plot %>%
        mutate(original_S_value = 10^S_value) # Back-transform to original species richness
      
      breaks_s_value <- c(1, 5, 10, 15, 20, 25, 30, 40, Inf) # Added 1 to catch values like 3-5
      
      # Define the labels for these bins
      levels_lab_snapshot <- c('1-5', '6-10', '11-15', '16-20', '21-25', '26-30', '31-40', '>40') # Adjusted 25-30 to 26-30 and 35-40 to 31-40, and >41 to >40 for consistency with breaks
      
      # Create the categorical variable using cut()
      dat_plot <- dat_plot %>%
        mutate(S_value_cat = cut(original_S_value,
                                 breaks = breaks_s_value,
                                 labels = levels_lab_snapshot,
                                 include.lowest = TRUE, # Include the lowest value (1 in this case)
                                 right = TRUE # (value > lower_bound and value <= upper_bound)
        ))
      
      cols_snapshot <- viridis(length(levels_lab_snapshot), option = "plasma")
      pal_snapshot <- colorFactor(palette = cols_snapshot, levels = levels_lab_snapshot)
      
      # Adjust point size by zooming level (this part remains the same)
      fac = 0.2
      zoomy = input$map_zoom
      # scale_factor = ifelse(zoomy*fac<=1, 1, zoomy*fac)
      scale_factor = zoomy*fac
      
      leafletProxy("map") %>%
        addCircleMarkers(data = dat_plot,
                         layerId = ~paste0("point_", geometry_id),
                         radius = ~(log(n)+2) * scale_factor,
                         color = ~pal_snapshot(S_value_cat), # Use the new categorical variable
                         stroke = FALSE,
                         fillOpacity = 0.7,
                         popup = ~paste0("Mean species richness: ", round(original_S_value, 2), # Show original value in popup
                                         "<br>No. plots: ", n)) %>%
        addLegend("topright",
                  pal = pal_snapshot, # Use the new categorical palette
                  values = dat_plot$S_value_cat, # Pass the categorical values for the legend
                  title = "Species richness",
                  opacity = 0.9)
    }
  })
  
  # Reactive value to store previous mode for smarter clearing
  prev_mode <- reactiveVal(NULL)
  
  # Observe changes in mode to clear markers efficiently
  observeEvent(input$mode, {
    # if mode changes, clear all markers
    if (!is.null(prev_mode()) && prev_mode() != input$mode) {
      leafletProxy("map") %>% clearMarkers()
    }
    prev_mode(input$mode)
  }, ignoreNULL = FALSE, ignoreInit = TRUE)
  
  # clear markers if habitat changes
  observeEvent(input$habitat, {
    leafletProxy("map") %>% clearMarkers()
  })
  
  # provide unique layerIds for efficient updates, use unique identifier:
  dat_with_id <- reactive({
    dat %>%
      # force unique ID for each geographic point
      mutate(geometry_id = paste0(x, "_", y, "_", habitat))
  })
  
  # update reactive data calls to use `dat_with_id`
  dat_sf <- reactive({
    dat_with_id() %>%
      st_as_sf(coords = c("x", "y"), crs = 25832) %>%
      filter(habitat == input$habitat) %>%
      st_transform(4326)
  })
  
}


#### 4. Run the app ####

shinyApp(ui, server)
